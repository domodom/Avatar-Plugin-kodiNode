const fs = require('fs-extra');
const path = require('path');
const klawSync = require('klaw-sync');

/*
  See http://js.cytoscape.org/  for further explantion and possibilities about CytoScape
  Stéphane Bascher
  avatar.home.automation@gmail.com
  For Avatar
*/


/*
 * Create an instance of Graph
 * @class Graph
 * @param {Object}  CY      An instance of Cytoscape.js corresponds to the graph
 * @param {String} folder   Plugin folder (needed to get path of images and elements)
 * @returns {Object}
 */
var Graph = function Graph (CY, folder) {
  this.CY = CY;
  this.pluginPath = folder;
}


/*
 * Get Graph instance
 * @param {none}
 * @returns {Object} Graph instance
 */
Graph.prototype.getGraph = function() {
    return new Promise((resolve, reject) => {
      this.CY ? resolve(this.CY) : reject ('Le graph n\'est pas initialisé')
    })
}


/*
 * Add element to Graph instance
 * @param {Object}    Graph instance
 * @param {String}    Id of the element
 * @returns {Object}  Element created
 */
Graph.prototype.addGraphElement = function(graph, id) {
  return new Promise((resolve, reject) => {
    graph.add({ group: "nodes",
              data: { id: id }
      });
    resolve (graph.$('#'+id));
  })
}


/*
 * Get element by ID
 * @param {String}    Id of the element
 * @returns {Object}  Element with Id
 */
Graph.prototype.getGraphElementByID = function(id) {
    return this.CY.$('#'+id);
}


/*
 * Get elements by Name and Class
 * @param {String}    Name of the element
 * @param {String}    Class of the element
 * @returns {Object}  Collection of all elements with same name and Class
 */
Graph.prototype.getGraphElementsByName = function(name, classe) {

  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    this.CY.nodes().forEach(function(ele) {
      if ((!classe && name == ele.data('name')) || (classe && name == ele.data('name') && ele.hasClass(classe)))
         collection = collection.union(ele);
    });
    resolve (collection);
  })
}


/*
 * Get element by Name and Class (optional)
 * @param {String}    Name of the element
 * @param {String}    Optional - Class of the element
 * @returns {Object}  last element with same name and Class
 */
Graph.prototype.getGraphElementByName = function(name, classe) {
    this.CY.nodes().forEach(function(ele) {
      if ((name == ele.data('name') && !classe) || (classe && name == ele.data('name') && ele.hasClass(classe)))
         elem = ele;
    });
    return elem;
}


/*
 * Get elements by Class
 * @param {String}    Class of the element
 * @returns {Object}  Collection of elements with the Class
 */
Graph.prototype.getGraphElementsByClass = function(classe) {
  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    this.CY.nodes().forEach(function(ele) {
      if (ele.hasClass(classe))
         collection = collection.union(ele);
    });
    resolve (collection);
  })
}


/*
 * Remove element by ID
 * @param {String}    ID of the element
 * @returns {none}
 */
Graph.prototype.removeGraphElementByID = function(id) {
  return new Promise((resolve, reject) => {
    this.CY.remove(this.CY.$('#'+id))
    resolve ();
  })
}


/*
 * Remove elements by Class
 * @param {String}    Class of elements
 * @returns {none}
 */
Graph.prototype.removeGraphElementsByClass = function(classe) {
  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    this.CY.nodes().forEach(function(ele) {
      if (ele.hasClass(classe))
         collection = collection.union(ele);
    });
    this.CY.remove(collection);
    resolve ();
  })
}


/*
 * Add class to the element
 * @param {Object}    Element
 * @param {String}    Class to add to the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementClass = function(elem, classe) {
  return new Promise((resolve, reject) => {
    elem.addClass(classe);
    resolve (elem);
  })
}


/*
 * Add image to the element
 * @param {Object}    Element
 * @param {String}    Full path image to add to the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementImage = function(elem, img) {
  return new Promise((resolve, reject) => {
    if (!img) return resolve (elem);

    let fs = require('fs-extra');
    if (!fs.existsSync(img)) return reject('Le fichier image '+img+' n\'existe pas');

    elem.style({
        'background-image': "url('"+img+"')"
    });
    resolve (elem);
  })
}


/*
 * Add rendering position to the element
 * @param {Object}    Element
 * @param {Integer}   X Position
 * @param {Integer}   Y Position
 * @returns {Object}  Element
 */
Graph.prototype.addElementRenderedPosition = function(elem, posX, posY) {
  return new Promise((resolve, reject) => {
    elem.renderedPosition('x', posX);
    elem.renderedPosition('y', posY);
    resolve (elem);
  })
}


/*
 * Add Name to the element
 * @param {Object}    Element
 * @param {String}    Name of the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementName = function(elem, data) {
  return new Promise((resolve, reject) => {
    if (!data) return resolve (elem);
    elem.data('name', data);
    resolve (elem);
  })
}


/*
 * Add size to the element
 * @param {Object}    Element
 * @param {Integer}   size of the element
 * @returns {Object}  Element
 */
Graph.prototype.addElementSize = function(elem, size) {
  return new Promise((resolve, reject) => {
    elem.style({
      'height': size,
      'width': size
    });
    resolve (elem);
  })
}


/*
 * Add border to the element
 * @param {Object}    Element
 * @param {String}    Optional - Color, default "white", can be rgba, direct string color, HEX code
 * @param {Integer}   Optional - Size of the border, default 6
 * @param {Integer}   Optional - Opacity of the border, default 0
 * @returns {Object}  Element
 */
Graph.prototype.addElementBorder = function(elem, color, width, opacity) {
  return new Promise((resolve, reject) => {
    elem.style({
      'border-color': color ? color : "white",
      'border-width': width ? width : 6,
      'border-opacity': opacity ? opacity : 0,
    });
    resolve (elem);
  })
}


/*
 * Add text font to the element
 * @param {Object}    Element
 * @param {Object}    Font description. See the function to know all possible params
                      Is is not mandatory to specify all params. Only what you want.
 * @returns {Object}  Element
 */
Graph.prototype.addElementFont = function(elem, options) {
  return new Promise((resolve, reject) => {
    let style = {};
    if (options['font-family']) style['font-family'] = options['font-family'];
    if (options['font-size']) style['font-size'] = options['font-size'];
    if (options['color']) style['color'] = options['color'];
    if (options['text-wrap']) style['text-wrap'] = options['text-wrap'];
    if (options['text-valign']) style['text-valign'] = options['text-valign'];
    if (options['text-halign']) style['text-halign'] = options['text-halign'];
    if (options['text-margin-x']) style['text-margin-x'] = options['text-margin-x'];
    if (options['text-margin-y']) style['text-margin-y'] = options['text-margin-y'];
    if (options['text-outline-width']) style['text-outline-width'] = options['text-outline-width'];
    if (options['text-outline-color']) style['text-outline-color'] = options['text-outline-color'];
    if (options['text-opacity']) style['text-opacity'] = options['text-opacity'];

    elem.style(style);
    resolve (elem);
  })
}


/*
 * Set/Unset the selection of the element
 * @param {Object}    Element
 * @param {Boolean}   Optional - selection, default false
 * @returns {Object}  Element
 */
Graph.prototype.selectElement = function(elem, selected) {
  return new Promise((resolve, reject) => {
    if (selected) {
      elem.data('selected', true);
      elem.style ({'border-opacity': 1});
    } else {
      elem.data('selected', false);
      elem.style ({'border-opacity': 0});
    }
    resolve (elem);
  })
}


/*
 * Lock/Unlock position of the element
 * @param {Object}    Element
 * @param {Boolean}   Optional - lock, default false
 * @returns {Object}  Element
 */
Graph.prototype.lockElement = function(elem, locked) {
  return new Promise((resolve, reject) => {
    if (locked)
      elem.lock();
    else
      elem.unlock();
    resolve (elem);
  })
}


/*
 * Get if the element is locked
 * @param {Object}    Element
 * @returns {Boolean} true if the element is locked, false otherwize
 */
Graph.prototype.isElementLocked = function(elem) {
  return elem.locked();
}


/*
 * Get if the element is selected
 * @param {Object}    Element
 * @returns {Boolean} true if the element is selected, false otherwize
 */
Graph.prototype.isElementSelected = function(elem) {
  return elem.data('selected');
}


/*
 * Event Click for the element
 * @param {Object}    Element
 * @param {function}  The function to execute on click...
 * @returns {Object}  Element
 */
Graph.prototype.onClick = function(elem, callback) {
  return new Promise((resolve, reject) => {
    elem.on('tap', function(evt){
      callback(elem);
    });
    resolve (elem);
  })
}


Graph.prototype.onHoldClick = function(elem, callback) {
  return new Promise((resolve, reject) => {
    elem.on('tap', function(evt){
      callback(elem);
    });
    resolve (elem);
  })
}

/*
 * Event Right Click for the element
 * @param {Object}    Element
 * @param {function}  The function to execute on rigth click...
 * @returns {Object}  Element
 */
Graph.prototype.onRightClick = function(elem, callback) {
  return new Promise((resolve, reject) => {
    elem.on('cxttap', function(evt){
      callback(elem);
    });
    resolve (elem);
  })
}


/*
 * Load elements by saved JSon files in the assets/nodes folder
 * @param {none}
 * @returns {Object}  Collection of all elements loaded
 */
Graph.prototype.loadAllGraphElements = function() {

  return new Promise((resolve, reject) => {
    var collection = this.CY.collection();
    if (fs.existsSync(this.pluginPath+'/assets/nodes')) {
      let nodes = klawSync(path.normalize (this.pluginPath+'/assets/nodes'), {nodir: true, depthLimit: 1});
      for (let i=0; i < nodes.length; i++) {
        let nodeJson = fs.readJsonSync (nodes[i].path, { throws: false });
        this.addGraphElement(this.CY, nodeJson.id)
        .then(elem => {
          return new Promise((resolve, reject) => {
            collection = collection.union(elem);
            resolve(elem);
          })
        })
        .then(elem => {
            return new Promise((resolve, reject) => {
              for (let i in nodeJson.classes) {
                this.addElementClass(elem, i)
              }
              resolve(elem);
            })
        })
        .then(elem => this.addElementName(elem, (nodeJson.name ? nodeJson.name : null)))
        .then(elem => this.addElementRenderedPosition(elem, nodeJson.position.x, nodeJson.position.y))
        .then(elem => {
          return new Promise((resolve, reject) => {
            elem.style(nodeJson.style);
            resolve(elem);
          })
        })
        .then(elem => this.selectElement(elem, nodeJson.selected))
        .then(elem => this.lockElement(elem, nodeJson.locked))
        .then(elem => {
          if ((i+1) == nodes.length)
            resolve (collection);
        })
        .catch (err => {
          console.log('err', err);
          resolve ();
        })
      }

      if (nodes.length == 0) resolve (collection);
    } else {
      resolve (collection);
    }
  });

}


/*
 * Save elements to JSon files in the assets/nodes folder
 * @param {String}    Class of elements to save as Json files
 * @returns {none}
 */
Graph.prototype.saveAllGraphElements = function(classe) {
  return new Promise((resolve, reject) => {
    this.CY.nodes().forEach((ele) => {

      if (classe && ele.hasClass(classe)) {
        let style = {};
        style.id = ele.id();
        if (ele.data('name')) style.name = ele.data('name');
        style.classes = ele._private.classes._obj;
        style.selected = (ele.data('selected')) ? ele.data('selected') : false;
        style.locked  = ele.locked();
        style.position = {};
        style.position.x = ele.renderedPosition('x');
        style.position.y = ele.renderedPosition('y');
        style.style = {};
        if (ele._private.style['background-image'])
          style.style["background-image"] = path.normalize(ele._private.style['background-image'].strValue);
        style.style.height = ele.height();
        style.style.width =  ele.width();
        if (ele._private.style['border-color'])
          style.style['border-color'] = ele._private.style['border-color'].strValue;
        if (ele._private.style['border-width'])
          style.style['border-width'] = ele._private.style['border-width'].value;
        if (ele._private.style['border-opacity'])
          style.style['border-opacity'] = ele._private.style['border-opacity'].value;
        if (ele._private.style['font-family'])
          style.style['font-family'] = ele._private.style['font-family'].strValue;
        if (ele._private.style['font-size'])
          style.style['font-size'] = ele._private.style['font-size'].strValue;
        if (ele._private.style['color'])
          style.style['color'] = ele._private.style['color'].strValue;
        if (ele._private.style['text-wrap'])
          style.style['text-wrap'] = ele._private.style['text-wrap'].value;
        if (ele._private.style['text-valign'])
          style.style['text-valign'] = ele._private.style['text-valign'].value;
        if (ele._private.style['text-halign'])
          style.style['text-halign'] = ele._private.style['text-halign'].value;
        if (ele._private.style['text-margin-x'])
          style.style['text-margin-x'] = ele._private.style['text-margin-x'].strValue;
        if (ele._private.style['text-margin-y'])
          style.style['text-margin-y'] = ele._private.style['text-margin-y'].strValue;
        if (ele._private.style['text-outline-width'])
          style.style['text-outline-width'] = ele._private.style['text-outline-width'].value;
        if (ele._private.style['text-outline-color'])
          style.style['text-outline-color'] = ele._private.style['text-outline-color'].strValue;
        if (ele._private.style['text-opacity'])
          style.style['text-opacity'] = ele._private.style['text-opacity'].value;

        let folder = path.normalize (this.pluginPath+'/assets/nodes');
        fs.ensureDirSync(folder);
        fs.writeJsonSync(folder+'/'+style.id+'.json', style);
      }
    });

    resolve ();
  })
}


/*
 *  Export Graph
 */
module.exports.Graph = Graph;
